# 推薦算法設計文檔

## 概覽

本服務實現了一個簡單但高效的推薦算法，適合 Phase 1 使用。算法結合熱度、用戶興趣匹配、新鮮度和隨機因子，確保推薦的多樣性和相關性。

---

## 核心算法

### 1. 推薦分數計算

每個內容的推薦分數是多個因素的加權組合：

```
推薦分數 = 0.4 × 熱度分數 + 0.35 × 興趣匹配分數 + 0.25 × 新鮮度分數
```

**權重選擇理由**:
- **熱度 (40%)**: 已驗證的高質量內容
- **興趣匹配 (35%)**: 用戶個性化體驗
- **新鮮度 (25%)**: 促進新內容發現

---

### 2. 熱度分數 (Popularity Score)

基於內容的觀看次數和點讚數計算：

```
熱度分數 = 0.3 × (觀看數 / 1000) + 0.7 × (點讚數 / 100)
```

**計算邏輯**:
1. 觀看數：正規化為 0-1 (基準: 1000 次)
2. 點讚數：正規化為 0-1 (基準: 100 個)
3. 點讚比重更高 (0.7) 因為代表用戶的主動互動

**示例**:
```
內容 A: 500 次觀看，50 個讚
熱度分數 = 0.3 × 0.5 + 0.7 × 0.5 = 0.5

內容 B: 1000 次觀看，80 個讚
熱度分數 = 0.3 × 1.0 + 0.7 × 0.8 = 0.86
```

---

### 3. 興趣匹配分數 (Interest Match Score)

基於用戶興趣和內容標籤的相似度：

```
興趣匹配分數 = Σ(用戶標籤興趣度) / 內容標籤總數
```

**計算邏輯**:
1. 獲取用戶的所有興趣標籤及其興趣度 (0-1)
2. 計算內容標籤中有多少與用戶興趣匹配
3. 求平均匹配度

**特殊情況**:
- 新用戶 (無興趣記錄): 返回 0.5 (中等分數)
- 無標籤內容: 返回 0.3 (較低分數)

**示例**:
```
用戶興趣: 
  - 'tech' → 0.8
  - 'news' → 0.6
  - 'sports' → 0.3

內容標籤: ['tech', 'news']
興趣匹配分數 = (0.8 + 0.6) / 2 = 0.7
```

---

### 4. 新鮮度分數 (Newness Score)

基於內容發布時間的指數衰減：

```
新鮮度分數 = e^(-age_hours / 72)
```

**特點**:
- 24 小時內: ~1.0
- 7 天後: ~0.3
- 最低: 0.1 (即使很舊也有基礎分數)

**公式詳解**:
- 指數衰減 (e^x) 模擬自然的時間價值遞減
- 72 小時的時間常數 = 3 天為半衰期
- 基礎分數 0.1 確保不會完全淘汰舊內容

**示例**:
```
發布時間分析:
- 12 小時前: 新鮮度 = 0.92
- 24 小時前: 新鮮度 = 0.84
- 72 小時前: 新鮮度 = 0.37 (半衰期)
- 168 小時前: 新鮮度 = 0.10
```

---

## 推薦邏輯流程

### 步驟 1: 分層推薦

1. **排序所有內容** (按推薦分數降序)
2. **分出確定性結果** (前 80%)
3. **分出隨機探索池** (後 20%)

```
例: 推薦 20 個內容
├─ 確定性 (16): 分數最高的 16 個
└─ 隨機探索 (4): 從剩餘池隨機選 4 個
```

### 步驟 2: 隨機打亂

打亂確定性和隨機探索的排序，避免單調。

### 步驟 3: 返回結果

返回最終的 20 個推薦內容。

---

## 用戶興趣模型更新

### 異步更新（非阻塞）

推薦查詢完成後，異步後臺更新用戶興趣模型：

```
setTimeout(() => {
  for each content in recommendations {
    for each tag in content.tags {
      if (user_interest exists)
        user_interest.score += 0.05 (最高 1.0)
      else
        create new interest with score 0.6
    }
  }
}, 100ms)
```

**優勢**:
- 不阻塞主請求 (100ms 延遲)
- 持續學習用戶偏好
- 推薦質量隨時間改善

---

## 快取策略

### Redis 快取結構

```
Key: "recommendations:{userId}:{limit}"
Value: [{ content_id, title, tags, score, reason }, ...]
TTL: 3600 秒 (1 小時)
```

### 快取失效場景

1. **用戶互動記錄** → 清空該用戶的所有快取
2. **內容分數更新** → 清空所有推薦快取
3. **手動刷新** → 用戶請求清空

---

## 性能優化

### 時間複雜度

| 操作 | 複雜度 | 說明 |
|------|-------|------|
| 快取命中 | O(1) | Redis 查詢 |
| 推薦計算 | O(n*m) | n=內容數, m=平均標籤數 |
| 興趣更新 | O(k) | k=推薦內容 (異步) |

### 優化策略

1. **Redis 緩存** - 快速響應 (<50ms)
2. **批量計算** - 一次計算多個內容
3. **異步更新** - 後臺更新不阻塞主流程
4. **懶加載** - 只計算必要的內容

### 性能目標

| 指標 | 目標 | 現狀 |
|------|------|------|
| 快取命中 | <50ms | ✅ |
| 完整計算 | <500ms | ✅ |
| 並發用戶 | 1000+ | ✅ |

---

## 示例場景

### 場景 1: 新用戶

```
新用戶 (無歷史數據)

推薦分數組合:
├─ 熱度分數: 0.7 (使用全站热門内容)
├─ 興趣匹配: 0.5 (新用戶預設)
└─ 新鮮度: 0.8 (優先推薦新內容)

結果: 混合推薦新內容和熱門內容
```

### 場景 2: 活躍用戶

```
用戶 (已有興趣標籤: tech=0.8, news=0.6)

推薦分數組合:
├─ 熱度分數: 0.6 (成熟內容)
├─ 興趣匹配: 0.75 (強匹配 tech/news)
└─ 新鮮度: 0.7 (混合新舊)

結果: 高度個性化推薦
```

### 場景 3: 隨機探索

```
20 個推薦中:
├─ 16 個: 確定性最高分數
└─ 4 個: 隨機選擇 (發現新內容)

使用者可能發現:
- 不在通常興趣範圍的內容
- 新興話題
- 小眾優質內容
```

---

## 未來改進方向 (Phase 2+)

1. **協作過濾** - 利用相似用戶的偏好
2. **內容協同過濾** - 相似內容捆綁推薦
3. **上下文感知** - 時間、地點、設備等
4. **A/B 測試** - 優化算法參數
5. **機器學習模型** - 神經網絡優化

---

## 配置參數

在 `.env` 中調整這些參數：

```bash
# 快取有效期 (秒)
RECOMMENDATION_CACHE_TTL=3600

# 批處理大小
RECOMMENDATION_BATCH_SIZE=50

# 隨機探索比例 (0-1)
RANDOM_EXPLORATION_RATIO=0.2
```

---

## 監控和調試

### 日誌輸出

```
[Recommendation] Cache hit for user user-123
[Recommendation] Recommendations cached for user user-123 with TTL 3600s
[Recommendation] Updated engagement scores for 150 contents
```

### 調試模式

設置 `LOG_LEVEL=debug` 查看詳細日誌。

---

## 測試覆蓋

- 推薦算法: 85%+
- 控制器: 80%+
- 服務: 80%+
- **總體**: 70%+

